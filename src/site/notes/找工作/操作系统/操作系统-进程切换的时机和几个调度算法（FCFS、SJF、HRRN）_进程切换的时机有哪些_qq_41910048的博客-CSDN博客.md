---
{"dg-publish":true,"date":"2023-12-08","time":"15:20","progress":"进行中","tags":["OS"],"permalink":"/找工作/操作系统/操作系统-进程切换的时机和几个调度算法（FCFS、SJF、HRRN）_进程切换的时机有哪些_qq_41910048的博客-CSDN博客/","dgPassFrontmatter":true}
---



###  **1.进程切换的时机**

 这个简单说说，进程切换主要分为两种，主动的放弃处理器和被动的放弃处理器。

其中主动放弃处理器的场景是

1. 进程正常结束，主动放弃。

2. 进程在执行时发生了异常。（**典型的缺页异常会导致进程切换，debug应该也会**）

被动放弃处理器的场景是

1. 进程在执行时有个更紧急的任务(比如IO操作)

2. 遇到有更高 [优先级 ](https://so.csdn.net/so/search?q=%E4%BC%98%E5%85%88%E7%BA%A7&spm=1001.2101.3001.7020)的进程

3. 进程的时间片过期



###  **2.几个进程调度的算法**



**先来看第一个 FCFS(First Come First Server) 先来先服务**

**就像排队买奶茶，很公平，但是不一定高效率。**



![](https://imp-repo-1300501708.cos.ap-beijing.myqcloud.com/R82vb4H5JoSzZGxQd4XcCNfRnoc.png)



举个栗子:



![](https://imp-repo-1300501708.cos.ap-beijing.myqcloud.com/EDlTbRPqFo2TwtxdSRncvMbJnGg.png)



比如有四个进程P1、P2、P3、P4四个进程，到达时间和运行时间如上表。

因为先来先服务，所以调度的顺序是P1->P2->P3->P4。

然后计算周转时间、等待时间、带权周转时间。

周转时间=完成时间-到达时间

带权周转时间=周转时间/运行时间

等待时间=周转时间-运行时间



![](https://imp-repo-1300501708.cos.ap-beijing.myqcloud.com/ImuXbroIxo6YXRxpkNrccxj9nZf.png)



(完成时间是累加起来的,比如P2的完成时间就是P1的运行时间+P2的运行时间=7+4)

P1：周转时间=7-0=7;带权周转时间=7/7=1;等待时间=7-0-7=0;

p2: 周转时间=11-2=9;带权周转时间=11-2/4=2.25;等待时间=11-2-4=5;

p3: 周转时间=12-4=8;带权周转时间=12-4/1;等待时间=12-4-1=7;

p4: 周转时间=16-5=11;带权周转时间=16-5/4=2.75;等待时间=16-5-4=7;



**第二个SJF(Shortest Job First) 短任务优先**



![](https://imp-repo-1300501708.cos.ap-beijing.myqcloud.com/JZUlbFm9Go3QAcx3qvOcLxg0nVc.png)



**最短任务优先调度算法，每当有进程进入就绪队列就需要调度，如果新来的进程剩余时间比当前运行的进程剩余时间更短，那么则新进程会抢占处理器,当前进程重回就绪队列。另外，当一个进程完成时，也需要调度。**



![](https://imp-repo-1300501708.cos.ap-beijing.myqcloud.com/HQ9bbIL5coNRcJxvdwXcZBnunlg.png)



还是之前的那张表，四个进程P1,P2,P3,P4。

计算公式还是和之前一样

周转时间=完成时间-到达时间

带权周转时间=周转时间/运行时间

等待时间=周转时间-运行时间

**但是结果却和FCFS算法不一样，由于短任务先执行，所以新来的进程剩余时间短于当前进程的剩余时间那么就会抢占处理器。**



![](https://imp-repo-1300501708.cos.ap-beijing.myqcloud.com/YjN1bSAJhocUGgxJFT4cYpqCnMi.png)



在0时刻，P1进程到达，P1进程的剩余时间为7。

在2时刻，P2进程到达，P1进程剩余时间为7-2=5，P2进程的剩余时间为4,所以此时，P2进程抢占处理器,P1进程重回就绪队列，当前进程切换为P2。

在4时刻，P3进程到达，P2进程剩余时间为4-2=2，P3进程剩余时间为1，所以P3进程抢占处理器，P2进程重回就绪队列。

在5时刻，P4进程到达，P3剩余时间为0，主动让出处理器，P4进程剩余时间为4，就绪队列中的P2进程剩余时间为2,P1进程剩余时间为5,所以P2进程被调度，P4进程重回就绪队列。

在7时刻，P2进程完成，主动让出处理器，就绪队列中P1进程剩余时间为5,P4进程剩余时间为4，所以调度P4进程。

在11时刻，P4进程完成，主动让出处理器，就绪队列中的P1进程被调度。

在16时刻，P1进程完成。

因此，计算周转时间、带权周转时间、等待时间。

P1周转时间=16-0=16;P1带权周转时间=16-0/7=2.28;P1等待时间=16-0-7=9;

P2周转时间=7-2=5;P2带权周转时间=7-2/4=1.25;等待时间=7-2-4=1;

P3周转时间=5-4=1;P3带权周转时间=5-4/1=1;等待时间=5-4-1=0;

P4周转时间=11-5=6;P4带权周转时间=11-5/4=1.5;等待时间=11-5-4=2;



细心同学可能发现了，如果不停的有剩余时间短的进程到达，那么进入就绪队列的进程将一直等待。这就是饥饿现象。如果就绪队列的进程一直得不到调度，就会"饿死"。

SJF调度算法不一定平均周转时间少，但是比起FCFS调度算法，SJF算法相对的平均周转时间和平均等待时间都比FCFS算法短。

**第三个HRRN调度算法（Highest Response Radio Next）高响应比优先算法**



![](https://imp-repo-1300501708.cos.ap-beijing.myqcloud.com/PlfLblheroUSYgxlFimcaiqUn7c.png)



高响应比优先算法：这个算法不是一个抢占算法，只有当前进程主动放弃CPU时，才会进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程进入处理器。

还是那个图



![](https://imp-repo-1300501708.cos.ap-beijing.myqcloud.com/N8CybqDHyovf8yxaS26cb6jjnhd.png)





![](https://imp-repo-1300501708.cos.ap-beijing.myqcloud.com/LQaAb1ErFoMG7dxO50ocjKMMnIb.png)



要求服务时间就是运行时间了。



![](https://imp-repo-1300501708.cos.ap-beijing.myqcloud.com/SsW8b1IeVoC9IexJfsbc9PJJn0g.png)







在0时刻，P1进程到达，进入处理器。

在7时刻，P1进程完成，主动放弃CPU,当前就绪队列中有P2、P3、P4，此时P2的响应比为(5+4)/4=2.25（因为这个时刻是7，而P2在2时刻就到达了，所以等待时间为5），P3的响应比为(3+1)/1=3，P4的响应比为(2+4/4=1.5)，响应比最高为P3,所以P3进程进入CPU。

在8时刻，P3进程完成，主动放弃CPU,当前就绪队列中剩余P2、P4，此时P2的响应比为(6+4)/4=2.5，P4的响应比为(3+4/4)=1.75，响应比最高为P2进程，P2进程进入CPU。

在12时刻，P2进程完成，主动放弃CPU,就绪队列中只剩下P4,P4进程进入处理器。

**由于HNNR调度算法考虑了等待时间和运行时间，所以等待时间相同时，服务时间短的作业优先。服务时间相同时，等待时间长的作业优先，那么对于长作业来说，进入就绪队列的时间越久，响应比就越大，进入CPU的机会就越大了，也就避免了“饥饿”的问题。**

