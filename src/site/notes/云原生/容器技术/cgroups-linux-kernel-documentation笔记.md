---
{"dg-publish":true,"date":"2024-06-01","time":"10:35","progress":"进行中","tags":["云原生/docker","linux/cgroup"],"permalink":"/云原生/容器技术/cgroups-linux-kernel-documentation笔记/","dgPassFrontmatter":true}
---



# cgroups-linux-kernel-documentation笔记


## 声明

本文为本人原创，未经授权严禁转载。如需转载需要在文章最前面注明本文原始链接。


原文： [[云原生/容器技术/cgroups-linux-kernel-documentation\|cgroups-linux-kernel-documentation]]



# 摘要

Linux 内核的 cgroup v2 是对 cgroup v1 的改进版本，它提供了一个单一的层次结构，而不是 cgroup v1 中的多个层次结构。cgroup v2 旨在更好地组织和分配系统资源，如 CPU 时间、内存和磁盘 I/O。该文档详细说明了 cgroup v2 的基本操作，包括挂载点的设置、如何组织进程和线程到不同的 cgroup 中，以及如何进行迁移。此外，还介绍了资源分配模型，包括权重、限制、保护和配额。

文档还详细描述了接口文件的格式和约定，包括核心接口文件和各个控制器的接口文件。控制器负责特定类型的资源分配，如 CPU、内存、磁盘 I/O 等。每个控制器都有自己的接口文件，用于配置和监控相应的资源。

文档中还讨论了 cgroup 的命名空间，这允许在容器环境中为不同的容器提供隔离的 cgroup 视图。此外，还提供了有关内核编程的信息，特别是文件系统如何支持写入后台（writeback）操作。

最后，文档对 cgroup v1 的一些功能进行了废弃，并讨论了从 cgroup v1 迁移到 cgroup v2 的理由。这些理由包括处理多个层次结构的复杂性、线程级粒度的问题、内部节点与线程之间的竞争问题，以及其他接口问题。文档还阐述了控制器问题及其解决方案，特别是针对内存控制器的改进。


- **单一层次结构**: cgroup v2 采用单一的层次结构，而不是 cgroup v1 的多个层次结构，以简化资源管理。
- **进程和线程组织**: cgroup v2 允许更灵活地组织进程和线程，并支持线程级资源分配。
- **资源分配模型**: cgroup v2 引入了权重、限制、保护和配额等资源分配模型，以更精细地控制资源分配。
- **接口文件规范**: cgroup v2 为了提供一致的用户体验，对接口文件的格式和约定进行了规范。
- **命名空间**: cgroup v2 支持命名空间，为容器化环境提供了更好的资源隔离。
- **内核编程支持**: 提供了关于如何在内核中支持 cgroup v2 的编程信息，特别是对于文件系统的写入后台（writeback）操作的支持。
- **迁移和废弃**: cgroup v2 的设计考虑了与 cgroup v1 的兼容性和迁移路径，同时对一些不再合理的 v1 功能进行了废弃。
- **控制器问题解决**: 针对 cgroup v1 中存在的内存控制器问题，cgroup v2 提供了改进的解决方案，包括引入了 memory.low 和 memory.high 边界，以及更合理的内存和交换空间控制。


# 各章节主要内容
## 1. 引言

- **术语**: "cgroup" 指代 "control group"，始终小写。单数形式指整个特性，复数形式指多个控制组。
- **cgroup 定义**: 一种层次化组织进程并在层次结构中以可控和可配置的方式分配系统资源的机制。

## 2. 基础操作

- **挂载**: cgroup v2 仅有单一层次结构，可通过特定命令挂载。
- **组织进程和线程**: 初始时仅有根 cgroup，可通过创建子目录创建子 cgroup。所有线程属于同一 cgroup。
- **\[Un\]populated Notification**: 非根 cgroup 有 "cgroup.events" 文件，指示其子层次结构中是否有活动进程。
- **控制控制器**: 通过 "cgroup.subtree_control" 文件启用或禁用控制器。
- **委托**: cgroup 可以通过目录权限或设置 "nsdelegate" 挂载选项委托给其他用户或命名空间。
- **指南**: 建议在启动时根据系统逻辑和资源结构分配工作负载至 cgroup，避免名称冲突。

## 3. 资源分配模型

- **权重**: 按子 cgroup 权重比例分配父级资源。
- **限制**: 子 cgroup 只能消耗配置的资源量。
- **保护**: 子 cgroup 在所有祖先的保护级别下可以被分配一定资源。
- **分配**: 子 cgroup 独占一定量的有限资源。

## 4. 接口文件

- **格式**: 包括新行分隔值、空格分隔值、平面键值和嵌套键值。
- **约定**: 单个特性设置在一个文件中，根 cgroup 免于资源控制。

## 5. 控制器

- **CPU**: 调节 CPU 周期分配，支持权重和绝对带宽限制模型。
- **内存**: 控制内存分配，支持限制和保护模型，跟踪多种内存使用情况。
- **IO**: 调节 IO 资源分配，支持权重和绝对带宽或 IOPS 限制。
- **PID**: 控制 cgroup 内创建新任务的数量。
- **设备**: 通过 BPF 程序管理对设备文件的访问。
- **RDMA**: 调节 RDMA 资源的分配和计量。
- **其他**: 如 perf_event 控制器，自动在 v2 层次结构上启用。

## 6. 命名空间

- **基础**: 提供虚拟化 "/proc/$PID/cgroup" 文件和 cgroup 挂载视图的机制。
- **根和视图**: cgroupns 根是调用 unshare(2) 的进程所在的 cgroup。
- **迁移和 setns(2)**: 进程可以在具有适当访问权限的情况下进入和离开命名空间根。
- **与其他命名空间的交互**: 特定于命名空间的 cgroup 层次结构可以由非初始 cgroup 命名空间内的进程挂载。

## P. 内核编程信息

- **写回文件系统支持**: 文件系统可以通过更新 writepage[s](chrome-extension://icmdpfpmbfijfllafmfogmdabhijlehn/side.html?url=https%3A%2F%2Fwww.kernel.org%2Fdoc%2FDocumentation%2Fcgroup-v2.txt&tabId=753068141) 来支持 cgroup 写回。

## R. 弃用 v1 核心特性

- 不支持多层次结构，包括命名层次结构。
- 移除 "tasks" 文件，"cgroup.procs" 不排序。
- 移除 "cgroup.clone_children"。
- /proc/cgroups 对 v2 无意义，使用根目录下的 "cgroup.controllers" 文件。

## D. v1 问题与 v2 理由

- **多层次结构**: 实际使用中不实用，限制了 cgroup 的使用和控制器能力。
- **线程粒度**: 允许线程属于不同 cgroup，模糊了应用程序和系统管理接口之间的界限。
- **内部节点和线程间的竞争**: 不同实体间竞争资源，难以解决。
- **其他接口问题**: cgroup v1 发展出许多特殊性和不一致性。
- **控制器问题和补救**: 内存控制器的原始软限制和硬限制存在问题，v2 版本进行了改进。


# cgroup的委托机制
在 cgroup v2 中，delegation是一种机制，它允许一个不完全信任的用户或进程管理自己的 cgroup 子树。这种机制对于容器化技术非常重要，因为它允许容器运行时和管理程序在不同的命名空间中为容器分配资源，同时保持与宿主机系统的隔离。cgroup v2 支持两种 delegation 方式：

## 第一种方式：给予较低特权的用户权限
这种方式涉及将某个 cgroup 目录的写权限授予一个较低特权的用户。这样，该用户就可以在这个目录下创建和管理自己的 cgroup 子树。这包括创建子目录（代表子 cgroup），向这些子 cgroup 迁移进程，以及配置这些子 cgroup 中的资源控制器。

具体步骤如下：

创建一个新的 cgroup 目录：在 cgroup v2 的挂载点下创建一个新的目录，例如/sys/fs/cgroup/myapp。
- 更改目录的权限：将该目录的所有权更改给一个较低特权的用户。例如，使用chown和chmod命令将目录的所有者更改为非根用户，并确保该用户有权限写入目录。
- 配置 cgroup：用户现在可以在这个目录下创建接口文件，启用控制器，并向这个 cgroup 迁移进程。
这种方式的关键点在于，用户只能管理自己的子树，不能影响其他 cgroup 的配置，这样就保证了一定程度的隔离和安全性。

## 第二种方式：自动委托给 cgroup 命名空间
在 cgroup v2 中，如果在挂载 cgroup 文件系统时使用了nsdelegate选项，那么在创建新的 cgroup 命名空间时，相应的 cgroup 子树会自动被委托给这个命名空间。这意味着在该命名空间内的进程只能看到并操作自己命名空间的 cgroup 子树。

具体步骤如下：

- 挂载 cgroup v2 文件系统：使用nsdelegate选项挂载 cgroup 文件系统，例如mount -t cgroup2 -o nsdelegate none /mnt/cgroup。
- 创建 cgroup 命名空间：使用clone(2)或unshare(2)系统调用，并指定CLONE_NEWCGROUP标志，创建一个新的 cgroup 命名空间。
- 操作 cgroup：在新的命名空间内，进程只能看到和操作自己命名空间的 cgroup 子树。它们不能直接操作父命名空间的 cgroup。
这种方式的优点是，它与 Linux 命名空间的其他特性（如 PID 命名空间、网络命名空间等）很好地集成在一起，为容器提供了一个隔离的资源管理环境。

## 委托的限制和注意事项
- 含义: 被委托的 cgroup 不能有自己的进程，只能用于进一步分配资源。
- 隔离性: 委托的 cgroup 不能跨越命名空间边界迁移进程，这有助于防止恶意行为。
- 无法移除: 一旦一个 cgroup 被委托，它就不能被删除，直到所有的子 cgroup 都被删除。



通过这两种方式，cgroup v2 提供了灵活的资源管理和安全的委托机制，使得容器和其他隔离环境能够有效地管理和限制资源使用。